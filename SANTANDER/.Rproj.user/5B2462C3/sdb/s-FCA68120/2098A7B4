{
    "contents" : "library(xgboost); library(data.table); library(doParallel); library(pROC); library(bit64)\n\nset.seed(3*04*14*2016)\n\ntrain <- fread(\"D:\\\\kaggle\\\\SANTANDER\\\\DATA\\\\train.csv\", data.table = F)\n\ntest  <- fread(\"D:\\\\kaggle\\\\SANTANDER\\\\DATA\\\\test.csv\", data.table = F)\n\n\n# Removing IDs-------------------------------------------------------------------------------------------\n\ntrain$ID <- NULL\n\ntest.id <- test$ID\n\ntest$ID <- NULL\n\n\n# Extracting TARGET--------------------------------------------------------------------------------------\n\ntrain.y <- train$TARGET\n\ntrain$TARGET <- NULL\n\n# 0 count per line---------------------------------------------------------------------------------------\n\ncount0 <- function(x) {\n  \n  return( sum(x == 0) )\n  \n}\n\ntrain$n0 <- apply(train, 1, FUN=count0)\n\ntest$n0 <- apply(test, 1, FUN=count0)\n\n\n# Removing constant features-----------------------------------------------------------------------------\n\ncat(\"\\n## Removing the constants features.\\n\")\n\nfor (f in names(train)) {\n  \n  if (length(unique(train[[f]])) == 1) {\n    \n    cat(f, \"is constant in train. We delete it.\\n\")\n    \n    train[[f]] <- NULL\n    \n    test[[f]] <- NULL\n    \n  }\n  \n}\n\n\n# Removing identical features----------------------------------------------------------------------------\n\nfeatures_pair <- combn(names(train), 2, simplify = F)\n\ntoRemove <- c()\n\nfor(pair in features_pair) {\n  \n  f1 <- pair[1]\n  \n  f2 <- pair[2]\n  \n  \n  if (!(f1 %in% toRemove) & !(f2 %in% toRemove)) {\n    \n    if (all(train[[f1]] == train[[f2]])) {\n      \n      cat(f1, \"and\", f2, \"are equals.\\n\")\n      \n      toRemove <- c(toRemove, f2)\n      \n    }\n    \n  }\n  \n}\n\n\nfeature.names <- setdiff(names(train), toRemove)\n\n# feature.names <- (names(train))\n\ntrain <- train[, feature.names]\n\ntest <- test[, feature.names]\n\n\n# creation of holdout set-------------------------------------------------------------------------------------\n\nh <- sample(nrow(train), 10000)\n\ntraining <- train[-h, ]; training_response <- train.y[-h]\n\nholdout <- train[h, ]; holdout_response <- train.y[h]\n\n\n# training a model--------------------------------------------------------------------------------------------\n\n\ndtrain <- xgb.DMatrix(data=data.matrix(training), label=training_response, missing = NaN)\n\nwatchlist <- list(train=dtrain)\n\nparam <- list(  objective           = \"binary:logistic\", \n                \n                booster             = \"gbtree\",\n                \n                eval_metric         = \"auc\",\n                \n                eta                 = 0.0202048,\n                \n                max_depth           = 5,\n                \n                subsample           = 0.6815,\n                \n                colsample_bytree    = 0.701\n)\n\n\ncl <- makeCluster(detectCores()); registerDoParallel(cl)\n\nclf <- xgb.train( params              = param, \n                  \n                  data                = dtrain, \n                  \n                  nrounds             = 570, \n                  \n                  verbose             = 1,\n                  \n                  watchlist           = watchlist,\n                  \n                  maximize            = T\n)\n\n\n# prediction and auc calculation using holdout------------------------------------------------------------------------------------\n\n# check below code for NA\n\npreds <- predict(clf, data.matrix(holdout), missing = NaN)\n\nauc(response = holdout_response, predictor = preds )\n\n\n# create submission file---------------------------------------------------------------------------------------\n\n\npreds <- predict(clf, data.matrix(test), missing = NaN)\n\npreds <- predict(clf, data.matrix(test), missing = NaN, ntreelimit = 560)\n\n\n\nsubmission <- data.frame(ID=test.id, TARGET=preds)\n\ncat(\"saving the submission file\\n\")\n\nwrite.csv(submission, \"submission_04222016.csv\", row.names = F)\n\n\n##############################################################################################################\n\nlibrary('pROC')\n\nfor (i in 0:4) {\n  roc1 <- roc(cv[cv$fold == i,]$TARGET,cv[cv$fold == i,]$pred.x,percent=TRUE,\n              plot=TRUE, auc.polygon=TRUE, max.auc.polygon=TRUE, grid=TRUE,print.auc=TRUE, \n              show.thres=TRUE)\n  roc2 <- roc(cv[cv$fold == i,]$TARGET,cv[cv$fold == i,]$pred.y,plot=TRUE, \n              add=TRUE, percent=roc1$percent, col=\"red\")\n  Sys.sleep(10)\n}\n",
    "created" : 1461426577228.000,
    "dirty" : true,
    "encoding" : "",
    "folds" : "",
    "hash" : "1734260157",
    "id" : "2098A7B4",
    "lastKnownWriteTime" : 7011605692497750387,
    "path" : null,
    "project_path" : null,
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "type" : "r_source"
}