{
    "contents" : "# seperate tmp into seperate df's for char, num, binary, dates -- manipulate -- combine\n\n# Fields present\n\n# PersonalField 57\n\n# SalesField 15\n\n# CoverageField 11B\n\n# Field 6:12\n\n# QuoteNumber \n\n# Original_Quote_Date\n\n#  QuoteConversion_Flag\n\nprop.table(table(train$QuoteConversion_Flag))\n\n# combine train and test\n\n# seperate character and numeric columns\n\ntmp <- rbind(train[-3], test)\n\n#rm(train); rm(test)\n\n\n# seperation into  character columns----------------------------------------------------------------------\n\nchar <- rep(0, ncol(tmp))\n\nfor( i in 1:ncol(tmp)){\n  \n  if(class(tmp[[i]]) == \"character\"){\n    \n    char[i] <- c(names(tmp)[i])\n    \n  }\n}\n\nchar <- char[char != 0 ]\n\ntmp_char <- tmp[, char]\n\n#tmp_num <- tmp[ , !(names(tmp) %in% char)]\n\n\n# seperate column with date-----------------------------------------------------------------------\n\n\ntmp_char$Original_Quote_Date <- as.Date(tmp_char$Original_Quote_Date)\n\ntmp_date <- data.frame(tmp_char[, \"Original_Quote_Date\"])\n\ntmp_char$Original_Quote_Date <- NULL\n\nnames(tmp_date) <- \"Original_Quote_Date\"\n\n\n#seperate columns with binary components-----------------------------------------------------------\n\n\nbinary <- rep(0, ncol(tmp))\n\nfor( i in 1:ncol(tmp)){\n  \nif(length(table(tmp[[i]])) == 2){\n  \n  binary[i] <- c(names(tmp)[i])\n\n  }\n}\n\nbinary <- binary[binary != 0]\n\ntmp_binary <- tmp[, binary]\n\n\n\n# Numerical columns--------------------------------------------------------------------------------\n\ntmp_num <- tmp[ , !(names(tmp) %in% c(char, binary))]\n\n\n##################################################################################################\n\n# work with date df first \n\n# basics - deep exploration needed for further feature creation\n\ntmp_date$year <- year(tmp_date$Original_Quote_Date)\n\ntmp_date$wday <- wday(tmp_date$Original_Quote_Date)\n\ntmp_date$day <- day(tmp_date$Original_Quote_Date)\n\ntmp_date$month <- month(tmp_date$Original_Quote_Date)\n\n\n# working with character data------------------------------------------------------------------\n\n\ntmp_num$Field10 <- tmp_char$Field10\n\ntmp_char$Field10 <- NULL\n\nlapply(tmp_char, function(x) table(x))\n\n\n\n# options : 1. dummify for large & small column nos and check model performance; write codes fr both\n\n#         : 2. can`t use length ...and other modifications since the columns here are used as \n\n#              indicators\n\n#         : 3. check other ways for coding variables\n\n# basics ---- convert into numeric and use 1,2,3 counts-------------------------------------------\n\n# assuming text variables are categorical and replacing them with numeic ids\n\n# for reconverting types of some columns use data from tmp and delete cols in tmp_char\n\n\n\nfor(f in names(tmp_char)){\n  \n  levels <- unique(tmp_char[[f]])\n  \n  tmp_char[[f]] <- as.numeric(factor(tmp_char[[f]], levels = levels))\n  \n}\n\n\n\n###################################################################################################\n\n# apply condition here\n\n# dummfying columns with length lesser than 7\n\n\ndummy_char <- rep(0, ncol(tmp_char))\n\n\nfor( i in 1: ncol(tmp_char)){\n  \n  if(length(table(tmp[[i]])) < 10) {\n    \n    dummy_char[i] <- c(names(tmp_char)[i])\n  }\n}\n\n\ndummy_char <- dummy_char[ dummy_char != 0 ]\n\n\n# creation of dummy variables---------------------------------------------------------------------\n\n\ntmp_char_dummy <- tmp_char[ , dummy_char]\n\nlen = length(names(tmp_char_dummy))\n\n\n\nfor(i in 1:len){\n  \n  print(paste0(( i / len) * 100, \"%\"))\n  \n  levels <- unique(tmp_char_dummy[[i]])\n  \n  tmp_char_dummy[, i] <- factor(tmp_char_dummy[, i], levels = levels)\n  \n}\n\n\n\ngc()\n\ndummies <- dummyVars( ~., data = tmp_char_dummy)\n\ngc()\n\n\n\ntmp_char_dummy <- predict(dummies, newdata = tmp_char_dummy)\n\ntmp_char_dummy <- data.frame(tmp_char_dummy)\n\ndim(tmp_char_dummy)\n\n\n\n####################################################################################################\n\n# for numeric cols \n\nfor(i in names(tmp_num)) length(table(tmp_num[[i]]))\n\n#change application methods after data deep dive\n\n# 11152015 not changing any of default values\n\n###################################################################################################\n\n\n# since these columns are now numeric count(1,2,3)\n\n# run model with and without to check effect of these extra vars\n\n\n# include cols from numeric df\n\ntmp_factors = tmp_char\n\nlen = length(names(tmp_factors))\n\nfor (i in 1:len) {\n  \n  print(paste0( i / (len) *100, \"%\"))\n  \n  levels <- unique(tmp_char_dummy[[i]])\n  \n  tmp_factors[ , i] <- factor(tmp_factors[ , i], levels = levels)\n  \n}\n\n#Important step ^^^^\n\n#############################################################################################################\n\n\n# 2 way count\n\nnms <- combn(names(tmp_factors), 2)\n\ndim(nms)\n\nnms_df <- data.frame(nms) \n\nlen = length(names(nms_df))\n\n\nfor (i in 1:len) {\n  \n  nms_df[, i] <- as.character(nms_df[, i])\n  \n}\n\n\ntmp_count <- data.frame(id = 1:dim(tmp)[1])\n\nfor(i in 1:dim(nms_df)[2]){\n  \n  \n  #new df \n  \n  print(((i / dim(nms_df)[2]) * 100 ))\n  \n  tmp_count[, paste(i, \"_two\", sep=\"\")] <- my.f2cnt(th2 = tmp, \n                                                    \n                                                    vn1 = nms_df[1,i], \n                                                    \n                                                    vn2 = nms_df[2,i] )\n  \n}\n\n\n###############################################################################################################\n\n\n\n#3 way count\n\nnms <- combn(names(tmp_factors), 3)\n\ndim(nms)\n\nnms_df <- data.frame(nms);\n\nlen = length(names(nms_df))\n\n\nfor (i in 1:len) {\n  \n  print(paste0(( i / len) *100, \"%\"))\n  \n  nms_df[, i] <- as.character(nms_df[, i])\n  \n}\n\n\nfor(i in 1:dim(nms_df)[2]){\n  \n  #new df \n  \n  print((i / dim(nms_df)[2]) * 100)\n  \n  tmp_count[, paste(i, \"_three\", sep=\"\")] <- my.f3cnt(th2 = tmp, \n                                                      \n                                                      vn1 = nms_df[1,i], \n                                                      \n                                                      vn2 = nms_df[2,i], \n                                                      \n                                                      vn3 = nms_df[3,i])\n  \n}\n\n\n##############################################################################################################\n\n\n\n#one way count\n\nlen = dim(tmp_factors)[2]\n\nfor(i in 1:len){\n  \n  \n  print((i / len) * 100 )\n  \n  tmp_factors$x <- tmp_factors[, i]\n  \n  sum1 <- sqldf(\"select x, count(1) as cnt\n                \n                from tmp_factors  group by 1 \")\n  \n  tmp1 <- sqldf(\"select cnt from tmp_factors a left join sum1 b on a.x=b.x\")\n  \n  tmp_count[, paste(names(tmp_factors)[i], \"_one\", sep=\"\")] <- tmp1$cnt\n  \n}  \n \n\n################################################################################################\n\n",
    "created" : 1447500382576.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "554064195",
    "id" : "B2D99E8A",
    "lastKnownWriteTime" : 1447567126,
    "path" : "~/Kaggle/HOMESITE/EDA.R",
    "project_path" : "EDA.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "type" : "r_source"
}