{
    "contents" : "# Convert the TripTypes to numeric factors and subtract 1. \n\n# XGB appears to require 0-n for the num_class parameter.\n\n rm(list = ls())\n\nrequire(xgboost); require(readr); require(caret); require(doParallel); require(data.table); require(FeatureHashing); require(sqldf); require(dplyr)\n\nset.seed(12192015)\n\n################################################################################################################\n\n#read in data \n\n#train_raw <- read_csv(\"C:/Users/amulya/Documents/Kaggle/Walmart/train.csv\")\n\n#test_raw <- read_csv(\"C:/Users/amulya/Documents/Kaggle/Walmart/test.csv\")\n\nrequire(bit64)\n\ntrain_raw <- read_csv(\"D:/kaggle/walmart_seg/Data/train.csv\")\n\ntest_raw <- read_csv(\"D:/kaggle/walmart_seg/Data/test.csv\")\n\n\ntlabels <- as.numeric(as.factor(train_raw$TripType))-1\n\nresponse <- train_raw$TripType\n\ntrain_raw$TripType <- NULL\n\n\n# convert columns to numeric\n\nfeature.names <- names(train_raw)[!names(train_raw) %in% c(\"TripType\")]\n\n\nfor (f in feature.names) {\n  \n  if (class(train_raw[[f]]) == \"character\") {\n    \n    levels <- unique(c(train_raw[[f]], test_raw[[f]]))\n    \n    train_raw[[f]] <- as.integer(factor(train_raw[[f]], levels=levels))\n    \n    test_raw[[f]]  <- as.integer(factor(test_raw[[f]],  levels=levels))\n  }\n}\n\nstr(train_raw); str(test_raw)\n\ntmp <- rbind(train_raw, test_raw)\n\ntmp <- data.frame(tmp)\n\ntmp_factors = tmp[ , feature.names]; \n\nstr(tmp_factors)\n\n\nfor(f in names(tmp_factors)){\n  \n  levels <- unique(tmp_factors[, f])\n  \n  tmp_factors[,f] <- factor(tmp_factors[,f], levels = levels)\n  \n}\n\n\n\n#Important step ^^^^\n\n#############################################################################################################\n\n\n# 2 way count\n\nnms <- combn(names(tmp_factors), 2)\n\ndim(nms)\n\nnms_df <- data.frame(nms) \n\nlen = length(names(nms_df))\n\nfor (i in 1:len) {\n  \n  nms_df[, i] <- as.character(nms_df[, i])\n  \n}\n\ntmp_count <- data.frame(id = 1:dim(tmp)[1])\n\nfor(i in 1:dim(nms_df)[2]){\n  \n  \n  #new df \n  \n  print(((i / dim(nms_df)[2]) * 100 ))\n  \n  tmp_count[, paste(i, \"_two\", sep=\"\")] <- my.f2cnt(th2 = tmp, \n                                                    \n                                                    vn1 = nms_df[1,i], \n                                                    \n                                                    vn2 = nms_df[2,i] )\n  \n}\n\n###############################################################################################################\n\n#3 way count\n\n\nnms <- combn(names(tmp_factors), 3)\n\ndim(nms)\n\nnms_df <- data.frame(nms);\n\nlen = length(names(nms_df))\n\nfor (i in 1:len) {\n  \n  print(paste0(( i / len) *100, \"%\"))\n  \n  nms_df[, i] <- as.character(nms_df[, i])\n  \n}\n\nfor(i in 1:dim(nms_df)[2]){\n  \n  #new df \n  \n  print((i / dim(nms_df)[2]) * 100)\n  \n  tmp_count[, paste(i, \"_three\", sep=\"\")] <- my.f3cnt(th2 = tmp, \n                                                      \n                                                      vn1 = nms_df[1,i], \n                                                      \n                                                      vn2 = nms_df[2,i], \n                                                      \n                                                      vn3 = nms_df[3,i])\n  \n}\n\n\n##############################################################################################################\n\n\n\n#one way count\n\nlen = dim(tmp_factors)[2]\n\nfor(i in 1:len){\n  \n  \n  print((i / len) * 100 )\n  \n  tmp_factors$x <- tmp_factors[, i]\n  \n  sum1 <- sqldf(\"select x, count(1) as cnt\n                \n                from tmp_factors  group by 1 \")\n  \n  tmp1 <- sqldf(\"select cnt from tmp_factors a left join sum1 b on a.x=b.x\")\n  \n  tmp_count[, paste(names(tmp_factors)[i], \"_one\", sep=\"\")] <- tmp1$cnt\n  \n}  \n\n\n###########################################################################################################\n\n#dummify few columns\n\n\nname <- c(\"Weekday\", \"DepartmentDescription\", \"ScanCount\")\n\ntmp_dummy <- (tmp[ , name ])\n\nlen = length(names(tmp_dummy))\n\nfor (i in 1:len) {\n  \n  print(paste0(( i / len) * 100, \"%\"))\n  \n  levels <- unique(tmp_dummy[[i]])\n  \n  tmp_dummy[, i] <- as.factor(tmp_dummy[, i])\n  \n}\n\n\n\ndummies <- dummyVars( ~ ., data = tmp_dummy)\n\ngc()\n\ntmp_dummy <- predict(dummies, newdata = tmp_dummy)\n\ntmp_dummy <- data.frame(tmp_dummy)\n\ndim(tmp_dummy)\n\n#############################################################################################################\n\n\ntmp_str <- data.frame((tmp[ , \"DepartmentDescription\"]))\n\n\ntmp_str[is.na(tmp_str)] <- 0\n\n\nnames(tmp_str) = (\"Dept_Desc\")\n\n\n\n\n#convert columns from character to factors in a data frame\n\n# code sourced from Stack Overflow\n\n\ni <- sapply(tmp_str, is.factor)\n\n\ntmp_str[i] <- lapply(tmp_str[i], as.character)\n\n\ntmp_str[, paste0(\"str_len\")] <-  nchar(x = tmp_str$Dept_Desc) \n\n\n\n# calculate number of words\n\n\ntmp_str$Dept_Desc <- gsub(' {2,}',' ', tmp_str$Dept_Desc)\n\nlnth <- rep(0, nrow(tmp_str))\n\nfor(i in 1:nrow(tmp_str)) {\n  \n  lnth[i] <-  length(strsplit(tmp_str$Dept_Desc[i],' ')[[1]])\n  \n}\n\ntmp_str$num_wrd <- lnth\n\n\n############################################################################################################\n\ntmp_new = cbind.data.frame(tmp, tmp_count, tmp_dummy, tmp_str)\n\n\n\n\n\ntrain <- tmp_new[c(1:647054),]\n\ntest <- tmp_new[c(647055:1300700),]\n\ndim(train); dim(test)\n\n\n\n# Use the converted values as the label for XGB.\n\ntrain[is.na(train)] <- -1\n\ntest[is.na(test)] <- -1\n\nfeature.names <- names(train)\n\n\nfor (f in feature.names) {\n  \n  if (class(train[[f]]) == \"character\") {\n    \n    levels <- unique(c(train[[f]], test[[f]]))\n    \n    train[[f]] <- as.integer(factor(train[[f]], levels=levels))\n    \n    test[[f]]  <- as.integer(factor(test[[f]],  levels=levels))\n  }\n}\n\n\nxgbtrain <- xgb.DMatrix(data.matrix(train[, -c(1:2)]), label=tlabels, missing=NA)\n\n\n# Run XGB with an objective of multi:softprob and use the predict function to get your \n#probabilities.\n\n\nnumberOfClasses <- max(tlabels) + 1\n\nparam <- list(objective = \"multi:softprob\",\n              \n              eval_metric = \"mlogloss\",\n              \n              num_class = numberOfClasses,\n              \n              max_depth = 16,\n              \n              eta = 0.03,\n              \n              colsample_bytree = 0.8,\n              \n              subsample = 0.8\n)\n\ngc()\n\n\ncl <- makeCluster(detectCores()); registerDoParallel(cl)\n\n\nstart <- Sys.time()\n\n\n###########################################################################################\n\n\nclf <- xgb.train(params = param, data = xgbtrain, nrounds = 500, \n                 \n                 verbose = 1, maximize = F, nthread = 2)\n\n\ntime_taken <- Sys.time() - start\n\nxgbpred <- predict(clf, data.matrix(test[, -c(1)])) \n\n\n# Shape the predicted probabilites vector into a matrix.\n\n\nprobs <- t(matrix(xgbpred, nrow=38, ncol=length(xgbpred)/38))\n\n\n# Pull in the original TripTypes and replace the column names on the matrix. \n\n\n# I use a csv file with a single column of TripTypes.\n\ntypenames <- fread(\"D:\\\\kaggle\\\\walmart_seg\\\\tts.csv\")\n\n\ncolnames(probs) <- typenames[,tt]\n\n# Add in Visit Number and such, and rule the LeaderBoard\n\nsubmission = as.data.frame(probs)\n\nsubmission <- cbind.data.frame(VisitNumber = test$VisitNumber , submission) \n\nsubmission <- setDT(submission)\n\nsubmission <- (submission[ , lapply(.SD, mean), by = VisitNumber])\n\nwrite_csv(submission, \"D:/kaggle/walmart_seg/submission/12192015_3.csv\")\n",
    "created" : 1450507660723.000,
    "dirty" : true,
    "encoding" : "",
    "folds" : "",
    "hash" : "1276064839",
    "id" : "14D7A853",
    "lastKnownWriteTime" : 31244190569398375,
    "path" : null,
    "project_path" : null,
    "properties" : {
        "tempName" : "Untitled2"
    },
    "relative_order" : 7,
    "source_on_save" : false,
    "type" : "r_source"
}